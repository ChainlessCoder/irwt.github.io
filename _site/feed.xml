<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Lum Ramabaja</title>
    <description>Researcher</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Mon, 04 May 2020 00:08:11 +0200</pubDate>
    <lastBuildDate>Mon, 04 May 2020 00:08:11 +0200</lastBuildDate>
    <generator>Jekyll v3.8.5</generator>
    
      <item>
        <title>The Competitive Neuron - On the Formation of Memories and Neuronal Specialization</title>
        <description>&lt;h1 id=&quot;contents&quot;&gt;Contents&lt;/h1&gt;
&lt;h2 id=&quot;part-one&quot;&gt;Part One&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://lums.blog/the-blind-men-beyond-ghor&quot;&gt;The Blind Men Beyond Ghor&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;E Pluribus Unum&lt;/li&gt;
  &lt;li&gt;The Neuron&lt;/li&gt;
  &lt;li&gt;…&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 03 May 2020 00:00:00 +0200</pubDate>
        <link>http://localhost:4000/The-Competitive-Neuron</link>
        <guid isPermaLink="true">http://localhost:4000/The-Competitive-Neuron</guid>
        
        <category>Book</category>
        
        <category>Neuroscience</category>
        
        <category>Neurons</category>
        
        <category>Memory</category>
        
        
      </item>
    
      <item>
        <title>The Blind Men Beyond Ghor</title>
        <description>&lt;p&gt;This post is part of an ongoing online book. To access the other parts, please refer to the contents page of the &lt;a href=&quot;https://lums.blog/The-Competitive-Neuron&quot;&gt;book&lt;/a&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;em&gt;Beyond Ghor, there was a city. All its inhabitants were blind. A king with his entourage arrived nearby; he brought his army and camped in the desert. He had a mighty elephant, which he used to increase the people’s awe. The populace became anxious to see the elephant, and some sightless from among this blind community ran like fools to find it. As they did not even know the form or shape of the elephant, they groped sightlessly, gathering information by touching some part of it. Each thought that he knew something, because he could feel a part…. The man whose hand had reached an ear… said: “It is a large, rough thing, wide and broad, like a rug.” And the one who had felt the trunk said: “I have the real facts about it. It is like a straight and hollow pipe, awful and destructive.”. The one who had felt its feet and legs said: “It is mighty and firm, like a pillar.” Each had felt one part out of many. Each had perceived it wrongly….&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;cite&gt;Idries Shah - Tales of the Dervishes, 1967&lt;/cite&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;This ancient story was told to teach a simple lesson that is often ignored: The behaviour of a system cannot be known just by knowing the elements of which the system is made.&lt;/p&gt;

&lt;h1 id=&quot;introduction&quot;&gt;Introduction&lt;/h1&gt;
&lt;p&gt;We have come a long way since  Santiago Ramón y Cajal published his first iconic drawings of neurons back in the late 19th century. The sheer amount of discoveries made by scientists since then proves that we are gradually converging on an understanding of how the brain works. The ingenious techniques that neuroscientists are developing to record and analyze our brains, are now helping us illuminate one by one parts of a once unknown world. Whereas the neuronal morphology and the molecular mechanisms of different neural structures are relatively well understood, the bigger picture of how neuronal interactions form emergent phenomena remains enigmatic. More than a century after the neuron’s discovery, we still do not know how the neural circuity in our heads gives rise to the mind. Like the blind men beyond Ghor, we are still trying to make sense of the elephant ourselves.&lt;/p&gt;

&lt;p&gt;Humans in fact tried to understand the nature of the mind for centuries. For example, ancient Indian philosophers believed in the theory of Samskara. Samskara meant different things to different people, and it was always somehow mixed with religion. It represented the mental impressions, or psychological imprints of a person. Samskaras were explained as characteristics, or behavioral traits that one either possessed from the moment of birth, or that got shaped over time. Indian philosophers  of the Nyaya school of Hinduism understood that a newborn child has imprinted memories (even though they did not refer to it like that). They argued that a baby’s instinctive reach for the mother’s breast was a sign that the baby had some prior Samskara. Since no one provided the knowledge of the necessity of the mother’s breast to the baby, and since the baby did not form any samskaras so far, philosophers believed that the newborn’s knowledge came from a ‘‘prior experience’’.&lt;/p&gt;

&lt;p&gt;As always, it was the Ancient Greeks however that hit the nail on its head. Alcmaeon of Croton, one of the greatest minds of Ancient Greece, was the first one to propose that the brain is the organ of the mind. Even though this revelation might not sound like a big deal, it was a revolution in human knowledge. Up until then, it was not that obvious to people that the thinking happens in the brain. The brain was just another organ. Even the father of modern science, Democritus of Abdera, who formulated the atomic theory of the universe, was inspired by Alcmaeon’s discovery. Democritus concurred with Alcmaeon’s discovery and argued that perception is a purely mechanistic (or one might say algorithmic) process. He argued that thinking and feeling were just attributes of matter that emerge when organized in a sufficiently fine and complex way and not due to some spirit infused into matter by the gods. During the time of Democritus, where everything was fused with spirituality and mysticism, these were not only bold statements, they were world-shattering. We know that Democritus wrote several books about the mind and senses. Some of the known book titles were “On the Mind”, “On the Senses”, “On Flavors”, “On Colors”, and “On Logic”. None of Alcmaeon’s and Democritus’ books however survived, all we know are the titles and the references from other philosophers. Who knows where we would have been today, if only we would have managed to preserve the memory of these ancient giants.&lt;/p&gt;

&lt;p&gt;The Ancient Greeks answered the question of ‘‘where’’ the mind takes place. Today’s scientists on the other hand are trying to answer ‘‘how’’ the mind does what it does. How do we learn? Where and how are memories stored? How does consciousness form? These are quite abstract questions, which because of the way they are asked, are difficult to answer. I strongly believe that to answer these questions, we will have to question every neurobiological structure and biochemical process we see. Why is there a very long dendrite that emerges from the cell body of pyramidal cells? Why are so many excitatory neurons covered with dendritic spines? Why are most interneurons spineless? What’s the purpose of the backpropagating signal found inside neurons? Why do excitatory and inhibitory neurons look so different? What is the purpose of the enigmatic spine apparatus and why do axons also have such a similar organelle?&lt;/p&gt;

&lt;p&gt;I believe that these are the kind of questions that will allow us to reverse engineer the circuits that give rise to the algorithms of our minds. Patterns that repeat over and over again in nature tend to have an important role. In biology after all, form follows function. Instead of focusing on big philosophical questions, I argue that we can deduce and understand the algorithmic parts of the brain by questioning the patterns in the morphology and biochemical processes of neurons. As you can quickly notice, one needs to know some basic neurobiology, to understand the questions this book tries to answer. That’s why we are going to learn some basic neuroscience in later chapters. I hope that none of the readers get too boarded by the theory.&lt;/p&gt;

&lt;p&gt;Writing this book is turning out to be tricky. On the one hand, the book has to be technical enough so that scientists do not get annoyed, yet it has to be simple and clear enough, so that people from different backgrounds can nonetheless understand everything. Because of this, I decided that any term or concept used after the introduction, be it neurosciecne related or machine learning related, has to be explained in advance. My interest is after all to reach as many people as possible.&lt;/p&gt;

&lt;p&gt;After the last sentences, you might think something like ‘‘Machine learning? Wait a minute, I thought this book is about memory?’’. I believe that the concepts of machine learning can be quite useful to reverse engineer the algorithms of biological systems. The main focus of this book will be about how memories form and are stored. I will propose an interesting model to which I will refer to as the ‘‘the Koha model’’, or the ‘‘Koha hypothesis’’. It describes a concrete algorithm for how memories are formed and stored in neural circuits, and how a phenomena called ‘‘neuronal specialization’’ can emerge by following very simple rules. The Koha model tries to extend Hebb’s rule, with the necessary temporal attributes for an asynchronous system to function. We will see how neural competition is key for Hebb’s neural assemblies to form. Once we know how the Koha model works, I will also explain what the purpose of some neural structures might be from the context of the mind.&lt;/p&gt;

&lt;p&gt;My interest is not to write a philosophical, vaguely defined proposal for how memories are formed and stored. Instead I will use a more pragmatic approach and explain a concrete, simple to understand process for it. Even though we do not know all the biochemical puzzle pieces for this problem yet, we will see how by looking at many experiments, we can already come up with a simple unsupervised learning algorithm for neural circuits. I feel it is important to emphasize that while designing the Koha model, I tried to be as strict as possible on its biological plausibility, putting neurobiology first and machine learning second. There will be no complicated math, no unnecessary abstractions that have little to do with actual biology, nothing of that sort. This book is after all meant to help us get closer to deciphering the brain. Not that it is bad to write things in a mathematical way, on the contrary, mathematics is after all the language of the universe. But I feel that too many times, especially in academia, we tend to use mathematics to make things appear more complicated, rather than to simplify them. I will hopefully use the latter approach in this book.&lt;/p&gt;

&lt;p&gt;Instead of immediately trying to answer the big questions, we are going to ask well defined biological questions, like the ones mentioned earlier. We are then going to use the proposed answers to those questions as puzzle pieces for bigger questions, like ‘‘How are memories stored?’’. Often times knowing how to ask the right questions is even more important than the question itself. We will not only examine the Koha model, but the biological structures from which it emerges as well. We will see how many of the questions in neurobiology, including the ones mentioned earlier in this introduction, can be indirectly explained and understood through this model. Even if this hypothesis turns out not to reflect reality, I hope that the facts and the questions asked in this book will help others decipher the mind.&lt;/p&gt;
</description>
        <pubDate>Sun, 03 May 2020 00:00:00 +0200</pubDate>
        <link>http://localhost:4000/The-Blind-Men-Beyond-Ghor</link>
        <guid isPermaLink="true">http://localhost:4000/The-Blind-Men-Beyond-Ghor</guid>
        
        <category>Book</category>
        
        <category>Neuroscience</category>
        
        <category>Neurons</category>
        
        <category>Memory</category>
        
        
      </item>
    
      <item>
        <title>Using binary vector clocks to replace Ethereum transaction nonces</title>
        <description>&lt;h1 id=&quot;contents&quot;&gt;Contents&lt;/h1&gt;
&lt;ol id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#contents&quot; id=&quot;markdown-toc-contents&quot;&gt;Contents&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#abstract&quot; id=&quot;markdown-toc-abstract&quot;&gt;abstract&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#introduction&quot; id=&quot;markdown-toc-introduction&quot;&gt;Introduction&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#the-order-of-ethereum-transactions&quot; id=&quot;markdown-toc-the-order-of-ethereum-transactions&quot;&gt;The order of Ethereum Transactions&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#partial-orders-and-join-semilattices&quot; id=&quot;markdown-toc-partial-orders-and-join-semilattices&quot;&gt;Partial Orders and Join-Semilattices&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#the-binary-vector-clock&quot; id=&quot;markdown-toc-the-binary-vector-clock&quot;&gt;The Binary Vector Clock&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#the-inevitable-total-order-during-epoch-jumps&quot; id=&quot;markdown-toc-the-inevitable-total-order-during-epoch-jumps&quot;&gt;The inevitable total order during epoch jumps&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#conclusion&quot; id=&quot;markdown-toc-conclusion&quot;&gt;Conclusion&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;abstract&quot;&gt;abstract&lt;/h1&gt;
&lt;p&gt;In this blog post, I’ll present the idea of a Binary Vector Clock, a simple, yet space-efficient algorithm for generating a partial order of transactions in account-based blockchain systems. The Binary Vector Clock solves the problem of order dependency in systems such as Ethereum, caused by the total order of transactions that come from the same address holder. What that exactly means will become clear in a bit. The proposed algorithm has the same security as using regular transaction nonces, requires very little overhead, and can potentially result in a significant increase in throughput for systems like Ethereum. This paper was originally submitted on the 15th of April, 2020 on &lt;a href=&quot;https://arxiv.org/abs/2004.07087&quot;&gt;arxiv&lt;/a&gt;.&lt;/p&gt;

&lt;h1 id=&quot;introduction&quot;&gt;Introduction&lt;/h1&gt;
&lt;p&gt;There are generally two kinds of transaction models in blockchains: The UTXO model, and the account based model. The UTXO model was the first transaction model to be proposed and has many intriguing properties. In this paper however, we are going to focus on the account based model, more exactly on the one implemented by Ethereum. In the account based model, instead of having coins as unspent outputs like in the UTXO model, every participating node has an account, or a balance. When a transaction is created, the transaction’s value is simply reduced from the owners account, and added to someone else’s account. To understand the problem that the Binary Vector Clock tries to solve, let’s first look at the structure of an Ethereum transaction and how the &lt;em&gt;order&lt;/em&gt; of transactions is determined.&lt;/p&gt;

&lt;h1 id=&quot;the-order-of-ethereum-transactions&quot;&gt;The order of Ethereum Transactions&lt;/h1&gt;
&lt;p&gt;A transaction in Ethereum is essentially a message that gets signed by an account holder, also known as an externally owned account. Once a transaction gets created, it is broadcast to other nodes in the system, and eventually recorded by the Ethereum blockchain. The structure of an Ethereum transaction consist of:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;A &lt;em&gt;value&lt;/em&gt; (the amount of ether we want to transfer).&lt;/li&gt;
  &lt;li&gt;A &lt;em&gt;recipient&lt;/em&gt; (the address of the account to whom we want to send the transaction to).&lt;/li&gt;
  &lt;li&gt;A &lt;em&gt;gas price&lt;/em&gt; (much like a transaction fee. The gas price shows how much of a fee the originator of the transaction is willing to pay).&lt;/li&gt;
  &lt;li&gt;A &lt;em&gt;gas limit&lt;/em&gt; (the maximum fee that the originator is willing to pay).&lt;/li&gt;
  &lt;li&gt;&lt;em&gt;v,r,s&lt;/em&gt; (the three ECDSA digital signature components to prove that the originator truly formed the transaction).&lt;/li&gt;
  &lt;li&gt;A &lt;em&gt;data&lt;/em&gt; field (an optional field that can contain code, for when an account interacts with smart contracts).&lt;/li&gt;
  &lt;li&gt;And the &lt;em&gt;nonce&lt;/em&gt; (an account specific counter. Whenever a transaction from the address holder gets confirmed, the counter increments).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The nonce field is the field that is of particularly interest to us. The transaction nonce, not to be confused with the block nonce used for Proof of Work, is a scalar value that serves as a counter. The nonce shows the number of confirmed transactions that originated from the account. Having such a counter for each transaction has an interesting effect: It protects the user from transaction duplication. Let’s see what would happen if transactions had no nonce, to better understand why having such a counter is so important: Let’s say Alice sent Bob a completely valid transaction containing three ether. The signature turned out to be truly Alice’s, and the transaction got recorded on the blockchain. Bob however turns out to have a bad moral compass and wants more money. Without a transaction nonce, there is nothing to stop Bob from “replaying” Alice’s transaction, and claim again three ether. Bob could in fact repeat transmitting Alice’s old transaction to the network, until he gets all of Alice’s ether. Every time the transaction would be replayed, nodes in the system would think that it is a new transaction. In reality however, this is not what happens. By having a counter attached to the transaction, every transaction becomes unique. If let’s say Alice’s transaction has a nonce of 42, Bob will not be able to replay that transaction, as any new transaction coming from Alice would have to have a nonce greater than 42.&lt;/p&gt;

&lt;p&gt;There is however also another important reason to have a nonce in an account-based transaction: We want to be able to determine the &lt;em&gt;order&lt;/em&gt; of transactions. Let’s assume this time that Alice is sending two transactions, but the second transaction is dependent on the first one, i.e. running the second transaction before the first one is invalid (for whatever reason). In a centralized system this is no problem, one would simply confirm the first transaction first, and than continue with the second transaction. In a decentralized system however, nodes in the network might receive the second transaction before the first one. We cannot know in advance in which order nodes will perceive events. Without a counter, there would be no way for nodes in the network to tell which transaction comes first. If on the other hand the first transaction has a counter of 42 and the other transaction has the next counter (43), the order can be determined. If a node in the network thus receives the second transaction before the first one, it knows that it should ignore the second transaction, until the first transaction gets confirmed.&lt;/p&gt;

&lt;p&gt;This is a great feature, but it also has its shortcomings. If Alice were to send several transactions one after another, and one of the transactions does not get included in any block for some reason, e.g. the transaction turns out to be invalid, then none of the subsequent transactions get processed. Only after providing a transaction with the missing nonce, do all the other transactions get processed. 
This is no problem if every transaction depends on the previous one, but in most real-world applications that would not be the case. Many nodes have to create dozens of transactions in a short period of time, imposing an order dependency thus can result in transactions having to stay in mempools, even if they could have been processed sooner. The total order of transactions represents at the same time a great feature, and a serious scaling problem for account-based transaction models. In the following sections, I will present how we can overcome the problem of total order when processing transactions.&lt;/p&gt;

&lt;h1 id=&quot;partial-orders-and-join-semilattices&quot;&gt;Partial Orders and Join-Semilattices&lt;/h1&gt;
&lt;p&gt;Before jumping straight to how the Binary Vector Clock works, it is necessary to have a good grasp of what a partial order is. All of us intuitively understand the idea of “total orders” - One is smaller than two, five is greater than four, etc. In order theory, a set is said to have a total order, if for any element $a$ and $b$, a comparison is possible, i.e. either $a \leq b$ or $a \geq b$. For example: Every transaction nonce for an address, is comparable to any other transaction nonce for that address. We thus can easily know which transaction happened-before another transaction, thanks to the total order of transactions. But what if it does not matter in which order some of our transactions get confirmed? If eight out of ten transactions generated from an address holder could in fact be confirmed in any desired order, it would be quite wasteful not to do so. This is however what happens in today’s totally ordered account based transaction model.&lt;/p&gt;

&lt;p&gt;It would thus be of enormous interest if we could somehow “capture” the transaction independence for address holders. This is where partial orders become useful. A partially ordered set, is a set in which only certain pairs of elements are comparable, i.e. one element precedes the other in the ordering, but not every pair of elements is necessarily comparable.&lt;/p&gt;

&lt;p align=&quot;center&quot;&gt;
  &lt;img width=&quot;300&quot; height=&quot;300&quot; src=&quot;/assets/images/posts/2020/semilattice.png&quot; /&gt;
&lt;/p&gt;

&lt;p&gt;As an example to better understand what a partial order actually is, let’s look at the join-semilattice in figure 1. The diagram shows a set $S$ with eight vectors. We say that an element in $S$ ‘‘happened-before’’ another element, if and only if every value of vector $a$ is less than or equal to every corresponding value in vector $b$. For example: We can conclude that vector $(1,0,0)$ happened before vector $(1,1,0)$, because none of the values in vector $(1,0,0)$ are greater than in vector $(1,1,0)$ - We say that $(1,0,0)$ happened-before $(1,1,0)$. If on the other hand we try to compare vector $(1,1,0)$ and $(1,0,1)$, one can see that both vectors have values larger than the other vector at some indices. We say that this pair is &lt;em&gt;not comparable&lt;/em&gt;. One cannot determine which element occurred before the other one. Algorithms used in distributed systems, such as vector clocks, take advantage of partial orders. In the context of the distributed systems, having incomparable vectors, or “clocks”, usually means that the events occurred concurrently, and thus have no information of one another. In the case of the Binary Vector Clock on the other hand, incomparableness between two transactions does not indicate concurrency, it indicates that they occur &lt;em&gt;independently&lt;/em&gt;.&lt;/p&gt;

&lt;h1 id=&quot;the-binary-vector-clock&quot;&gt;The Binary Vector Clock&lt;/h1&gt;
&lt;p&gt;Let’s imagine that instead of a nonce (i.e. counter) for a transaction, we have a counter &lt;em&gt;and&lt;/em&gt; a very small bit array (for the sake of a better explanation, let’s stick to three bits, like the vectors in figure 1. Alice’s Binary Vector Clock is initially set to $(0, [0,0,0])$ (where the first element represents the counter and the second element the bit array). For simplicity, I will refer to the Binary Vector Clock from now on as a “timestamp”. Now let’s say Alice wants to send three transactions one after another. Alice however knows that her second transaction is dependent on her first transaction, but her third transaction has no logical dependency to the two first transactions. Having this information, Alice can do something clever: Instead of incrementing her counter for each transaction, she increments one of the bits in her bit array. Let’s say the first transaction has the timestamp $(0,[0,0,1])$, the second transaction has the timestamp  $(0,[0,1,1])$, and the third timestamp is $(0,[1,0,0])$. All three transactions were send one after another to the network. Any validator receiving the transactions can independently know in what order the transactions need to be confirmed (or if any order exists at all). Validators first look at the counter, the counter tells a validator if the transaction is in the right “epoch” (more on that in a bit). If the counter is equal to the previously confirmed transaction from that address, the bit array is checked. As the bit array of the first and third transaction are not comparable (no order can be determined), even if the first transaction turns out to be invalid for some reason, the third transaction can still be processed by the validators. This is because both timestamps are indicating “independentness”, there is no “happened-before” relationship between them. The second and the first transaction on the other hand do have a “happened-before” relationship. When looking at the bit array of the second transaction, we can conclude that it must have happened after the first transaction. If a validator thus would receive the third transaction and the second transaction, but not the first transaction for some reason, it would know that the third transaction can be processed, but the second transaction not, as it depends on a prior transaction (the first transaction). If a transaction gets confirmed, the address’ Binary Vector Clock gets simply added with the newly confirmed timestamp. Taking again the three transactions from the previous scenario as an example, if Alice’s initial timestamp was $(0,[0,0,0])$, and her first and third transactions get confirmed, her new timestamp would be $(0,[1,0,1])$. Once all the bits in the bit array are turned to one, we can increment the timestamp’s counter, and set the bit array to zero again. We call this shift an “epoch”.&lt;/p&gt;

&lt;p&gt;Up to this point, some of the readers might have already thought something in the lines of: But what if Alice has only one ether, and she creates three independent transactions, each spending one ether? It is important to remember that this is an issue only if transactions would be processed concurrently, which is not the case with the Binary Vector Clock technique. In cases like the one mentioned above, transactions would be treated the same way today’s transactions get treated, if they were to have the same nonce. Today, with the nonce approach, if transactions have the same nonce, one of the transactions would get confirmed (depending on the block creator) and the rest of the transactions would become invalid. In the case of the Binary Clock, one of Alice’s transactions (depending on the block creator) would get confirmed, while the rest of the transactions would simply be considered invalid, regardless of their order independency.&lt;/p&gt;

&lt;h1 id=&quot;the-inevitable-total-order-during-epoch-jumps&quot;&gt;The inevitable total order during epoch jumps&lt;/h1&gt;
&lt;p&gt;It is important to note that there is nonetheless an inevitable transaction processing dependency when shifting from one epoch to the next. Transactions from one epoch can only be processed independently, after the transactions of the previous epoch were already processed. In other words if Alice were to send three other transactions one after the other, where the first transaction would have a timestamp of $(0,[1,1,1])$, second transaction $(1,[1,0,0])$, and third transaction $(1,[0,0,1])$, even if all three transactions are completely independent from one another, the second and third transactions will not be able to get processed without the first one being confirmed first. This is because these transactions occurred during an epoch “jump”, i.e. the Binary Vector Clock gets incremented, and the bit array becomes set to zero. The transactions in the new epoch cannot know if they are comparable or not with the transaction from the previous epoch, forcing a momentary total order. I argue however that the space-wise inexpensive nature of the Binary Vector Clock, and its property to handle partial orders, makes it an attractive technique for the account-based transaction model, even in the case of momentary order dependencies between epoch jumps.&lt;/p&gt;

&lt;h1 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h1&gt;
&lt;p&gt;In This paper I introduced the Binary Vector Clock, a memory-wise inexpensive partially ordered counter for account-based transactions, that solves the issue of order dependency when processing transactions. Note that the Binary Vector Clock does not suggest the concurrent processing of transactions in Ethereum. Doing so would in fact introduce many possible attack vectors to the system. It only specifies which transactions can be processed independently, and which ones depend on a prior transaction confirmation. If for example an address generates $N$ transactions one after another, and the first transaction fails, the subsequent transactions are still able to get processed and confirmed by the blockchain. This is not the case in today’s approach with transaction nonces. In today’s approach, if the first transaction fails for some reason, all of the other transactions would need to be ignored until the gap in the nonce becomes filled. The Binary Vector Clock overcomes the issue by introducing a partial order between transactions of the same address holder. Using the Binary Vector Clock as a substitution for the transaction nonce gives more freedom to the user in determining transaction orders. The Binary Vector Clock allows the user to specify if a transaction can be processed  independently from other transactions, or if it should be queued until a certain transaction gets confirmed. I argue that this ability has important implications for blockchain systems. Considering that transactions in blockchain systems most likely follow a pareto distribution (the majority of transactions are generated by very few nodes), introducing an inexpensive technique that allows for independent processing of transactions, could potentially increase the scaling capability of Ethereum and other account-based blockchains significantly.&lt;/p&gt;
</description>
        <pubDate>Sat, 02 May 2020 00:00:00 +0200</pubDate>
        <link>http://localhost:4000/The-Binary-Vector-Clock</link>
        <guid isPermaLink="true">http://localhost:4000/The-Binary-Vector-Clock</guid>
        
        <category>Paper</category>
        
        <category>Vector Clock</category>
        
        <category>Ethereum</category>
        
        
      </item>
    
  </channel>
</rss>
